#! /usr/bin/python3
#
# Copyright (c) 2017-21 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#
# Because life is as it is, this is a mess, we need this same file
# next to each setup.py file
#
#  - symlinks don't work because the bdist_rpm MANIFEST doesn't
#    dereference
#
#  - importing by manipulating the sys.path doesn't work because them
#    when packaging the toplevel setupl.py is not incldued in the
# subpackages
#
# So rules:
#
# - DO NOT EDIT THIS FILE if it is not in the root
# - edit the root/setupl.py
# - cd tcf.git; for v in $(find -mindepth 2 -iname setup.py); do cp setupl.py $(dirname $v); done
#
import glob
import os
import re
import site
import subprocess
import sys
import time

import distutils.command.install_data
import distutils.command.install_scripts

def mk_version_py(base_dir, version):
    """
    Create a version.py file in a directory with whichever version
    string is passed.
    """
    print(f"DEBUG version {version}")
    with open(os.path.join(base_dir, "version.py"), "w") as f:
        f.write("""\
#! /usr/bin/python3
#
# Copyright (c) 2017 Intel Corporation
#
# SPDX-License-Identifier: Apache-2.0
#

# Generated by %s on %s
version_string = "%s"
""" % (__file__, time.asctime(), version))


# Run a post-install on installed data file replacing paths as we need
class _install_data(distutils.command.install_data.install_data):
    def run(self):
        # Workaround that install_data doesn't respect --prefix
        #
        # If prefix is given (via --user or via --prefix), then
        # extract it and add it to the paths in self.data_files;
        # otherwise, default to /usr/local.
        install = self.distribution.command_options.get('install', {})
        if 'user' in install:
            # this means --user was given
            self.prefix = site.getuserbase()
            sysconfigdir = os.path.join(self.prefix, 'etc')
        elif 'prefix' in install:
            # this means --prefix was given
            self.prefix = install.get('prefix', (None, None))[1]
            if self.prefix == "/usr":
                sysconfigdir = "/etc/"
            else:
                sysconfigdir = os.path.join(self.prefix, 'etc')
        else:
            # these have to be absolute, otherwise they will be prefixed again
            self.prefix = '/usr/local'
            sysconfigdir = '/etc'
        new_data_files = []
        for entry in self.data_files:
            dest_path = entry[0].replace('@prefix@', self.prefix)
            dest_path = dest_path.replace('@sysconfigdir@', sysconfigdir)
            new_data_files.append((dest_path,) + entry[1:])
        self.data_files = new_data_files
        distutils.command.install_data.install_data.run(self)

# Run a post-install on installed data file replacing paths as we need
class _install_scripts(distutils.command.install_scripts.install_scripts):
    def run(self):
        # Workaround that install_data doesn't respect --prefix
        #
        # If prefix is given (via --user or via --prefix), then
        # extract it and add it to the paths in self.data_files;
        # otherwise, default to /usr/local.
        install = self.distribution.command_options.get('install', {})
        if 'user' in install:
            # this means --user was given
            sysconfigdir = "~/.local/etc"
            sharedir = "~/.local/share"
        elif 'prefix' in install:
            # this means --prefix was given
            prefix = install.get('prefix', (None, None))[1]
            sysconfigdir = os.path.join(prefix, "etc")
            sharedir = os.path.join(prefix, "etc")
        else:
            sysconfigdir = "/etc"
            sharedir = "/usr/share"
        distutils.command.install_scripts.install_scripts.run(self)
        for filename in self.outfiles:
            try:
                subprocess.check_call(
                    [
                        'sed', '-i',
                        '-e',
                        's|install_time_etc_tcf = .*$' \
                        '|install_time_etc_tcf = "' + sysconfigdir + '/tcf"|g',
                        '-e',
                        's|install_time_share_tcf = .*$' \
                        '|install_time_share_tcf = "' + sharedir + '/tcf"|g',
                        filename
                    ])
            except subprocess.CalledProcessError as e:
                sys.stderr.write("FAILED: sed failed\n")
                raise
            
# A glob that filters symlinks
def glob_no_symlinks(pathname):
    l = []
    for file_name in glob.iglob(pathname):
        if not os.path.islink(file_name):
            l.append(file_name)
    return l


# Find which version string to settle on
version = None
try:
    import tcfl.version
    version = tcfl.version.version_string
except:
    pass

if "VERSION" in os.environ:
    version = os.environ['VERSION']
elif version:
    """ already have something """
else:
    _src = os.path.abspath(__file__)
    _srcdir = os.path.dirname(_src)
    try:
        version = subprocess.check_output(
            "git describe --tags --always --abbrev=7 --dirty".split(),
            cwd = _srcdir, stderr = subprocess.PIPE, encoding = "utf-8")
        # RPM versions can't have dash (-), so use underscores (_)
        version = version.strip().replace("-", ".")
        if re.match("^v[0-9]+.[0-9]+", version):
            version = version[1:]
    except subprocess.CalledProcessError as e:
        sys.stderr.write("FAILED: git failed: %s" % e.output)
        version = "vNA"
